// 문제 설명
// N개의 스티커가 원형으로 연결되어 있습니다. 다음 그림은 N = 8인 경우의 예시입니다.
// 스티커_hb1jty.jpg
// 원형으로 연결된 스티커에서 몇 장의 스티커를 뜯어내어 뜯어낸 스티커에 적힌 숫자의 합이 최대가 되도록 하고 싶습니다. 단 스티커 한 장을 뜯어내면 양쪽으로 인접해있는 스티커는 찢어져서 사용할 수 없게 됩니다.

// 예를 들어 위 그림에서 14가 적힌 스티커를 뜯으면 인접해있는 10, 6이 적힌 스티커는 사용할 수 없습니다. 
// 스티커에 적힌 숫자가 배열 형태로 주어질 때, 스티커를 뜯어내어 얻을 수 있는 숫자의 합의 최댓값을 return 하는 solution 함수를 완성해 주세요. 
// 원형의 스티커 모양을 위해 배열의 첫 번째 원소와 마지막 원소가 서로 연결되어 있다고 간주합니다.

// 제한 사항
// sticker는 원형으로 연결된 스티커의 각 칸에 적힌 숫자가 순서대로 들어있는 배열로, 길이(N)는 1 이상 100,000 이하입니다.
// sticker의 각 원소는 스티커의 각 칸에 적힌 숫자이며, 각 칸에 적힌 숫자는 1 이상 100 이하의 자연수입니다.
// 원형의 스티커 모양을 위해 sticker 배열의 첫 번째 원소와 마지막 원소가 서로 연결되어있다고 간주합니다.
// 입출력 예
// sticker	answer
// [14, 6, 5, 11, 3, 9, 2, 10]	36
// [1, 3, 2, 5, 4]	8
// 입출력 예 설명
// 입출력 예 #1
// 6, 11, 9, 10이 적힌 스티커를 떼어 냈을 때 36으로 최대가 됩니다.

// 입출력 예 #2
// 3, 5가 적힌 스티커를 떼어 냈을 때 8로 최대가 됩니다.

// GPT 풀이
class Solution {
    public int solution(int[] sticker) {
        int n = sticker.length;

        // 예외 케이스: 스티커가 1개면 그냥 그것이 최대값
        if (n == 1) return sticker[0];

        // -------------------------
        // Case 1: 첫 번째 스티커를 뜯는 경우
        //         → 마지막 스티커는 절대 못 뜯음!
        // -------------------------
        int[] dp1 = new int[n];
        dp1[0] = sticker[0];             // 0번 스티커를 선택했음
        dp1[1] = sticker[0];             // 1번 스티커는 선택 불가(0번과 인접)

        for (int i = 2; i < n - 1; i++) {
            // i번째 스티커를 선택하면 i-2까지의 최대값 + 현재 스티커 점수
            // i번째 스티커를 선택하지 않으면 i-1까지의 최대값 유지
            dp1[i] = Math.max(dp1[i - 1], dp1[i - 2] + sticker[i]);
        }

        // -------------------------
        // Case 2: 첫 번째 스티커를 뜯지 않는 경우
        //         → 마지막 스티커 뜯을 수 있음!
        // -------------------------
        int[] dp2 = new int[n];
        dp2[0] = 0;                      // 0번 스티커는 아예 선택 불가
        dp2[1] = sticker[1];            // 1번부터 시작 가능

        for (int i = 2; i < n; i++) {
            // 로직은 위와 동일, 단 시작점이 다름
            dp2[i] = Math.max(dp2[i - 1], dp2[i - 2] + sticker[i]);
        }

        // -------------------------
        // 두 케이스 중 더 큰 값이 정답
        // -------------------------
        // case1은 n-1까지 고려해야 하고 (마지막 스티커 제외)
        // case2는 n-1까지 모두 고려 가능 (마지막 포함)
        return Math.max(dp1[n - 2], dp2[n - 1]);
    }
}


///////// 내 풀이. 홀, 짝으로 나누는 것은 홀짝이 조합외에 최대값이 나올 수 있다.
class Solution {
    public int solution(int sticker[]) {
        int answer = 0;
        int tmp = 0;
        int index = 2 + (sticker.length % 2);

        for(int j = 0; j < index ; j++){
            for(int i = j ; i < sticker.length ; i+=2){
                if(j == 0){
                    if(i == (sticker.length - 1)){
                        continue;
                    }
                }

                if(j == (index - 1)){
                    if(i ==  0){
                        continue;
                    }
                }

                tmp += sticker[i];
            }
            if(answer < tmp){
                answer = tmp;
            }
            tmp = 0;
        }

        return answer;
    }
}