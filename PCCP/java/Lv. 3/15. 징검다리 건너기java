// [본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]

// 카카오 초등학교의 "니니즈 친구들"이 "라이언" 선생님과 함께 가을 소풍을 가는 중에 징검다리가 있는 개울을 만나서 건너편으로 건너려고 합니다. 
// "라이언" 선생님은 "니니즈 친구들"이 무사히 징검다리를 건널 수 있도록 다음과 같이 규칙을 만들었습니다.

// 징검다리는 일렬로 놓여 있고 각 징검다리의 디딤돌에는 모두 숫자가 적혀 있으며 디딤돌의 숫자는 한 번 밟을 때마다 1씩 줄어듭니다.
// 디딤돌의 숫자가 0이 되면 더 이상 밟을 수 없으며 이때는 그 다음 디딤돌로 한번에 여러 칸을 건너 뛸 수 있습니다.
// 단, 다음으로 밟을 수 있는 디딤돌이 여러 개인 경우 무조건 가장 가까운 디딤돌로만 건너뛸 수 있습니다.
// "니니즈 친구들"은 개울의 왼쪽에 있으며, 개울의 오른쪽 건너편에 도착해야 징검다리를 건넌 것으로 인정합니다.
// "니니즈 친구들"은 한 번에 한 명씩 징검다리를 건너야 하며, 한 친구가 징검다리를 모두 건넌 후에 그 다음 친구가 건너기 시작합니다.

// 디딤돌에 적힌 숫자가 순서대로 담긴 배열 stones와 한 번에 건너뛸 수 있는 디딤돌의 최대 칸수 k가 매개변수로 주어질 때, 
// 최대 몇 명까지 징검다리를 건널 수 있는지 return 하도록 solution 함수를 완성해주세요.

// [제한사항]
// 징검다리를 건너야 하는 니니즈 친구들의 수는 무제한 이라고 간주합니다.
// stones 배열의 크기는 1 이상 200,000 이하입니다.
// stones 배열 각 원소들의 값은 1 이상 200,000,000 이하인 자연수입니다.
// k는 1 이상 stones의 길이 이하인 자연수입니다.
// [입출력 예]
// stones	k	result
// [2, 4, 5, 3, 2, 1, 4, 2, 5, 1]	3	3
// 입출력 예에 대한 설명
// 입출력 예 #1

// 첫 번째 친구는 다음과 같이 징검다리를 건널 수 있습니다.
// [1, 3, 4, 2, 1, 0, 3, 1, 4, 0]

// 첫 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.
// 두 번째 친구도 아래 그림과 같이 징검다리를 건널 수 있습니다.
// [0, 2, 3, 1, 0, 0, 2, 0, 3, 0]

// 두 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.
// 세 번째 친구도 아래 그림과 같이 징검다리를 건널 수 있습니다.
// [0, 1, 2, 0, 0, 0, 1, 0, 2, 0]

// 세 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.
// 네 번째 친구가 징검다리를 건너려면, 세 번째 디딤돌에서 일곱 번째 디딤돌로 네 칸을 건너뛰어야 합니다. 하지만 k = 3 이므로 건너뛸 수 없습니다.
// step_stones_103.png

// 따라서 최대 3명이 디딤돌을 모두 건널 수 있습니다.

// GPT 답변
import java.util.*;

class Solution {
    public int solution(int[] stones, int k) {
        // 안전 체크: k가 배열 길이 범위를 벗어나면 예외
        if (stones == null || stones.length == 0 || k <= 0 || k > stones.length) {
            throw new IllegalArgumentException("invalid input");
        }

        Deque<Integer> dq = new ArrayDeque<>(); // 인덱스를 저장하는 데크(값이 내림차순이 되도록 유지)
        int answer = Integer.MAX_VALUE;         // 각 윈도우 최대들의 '최솟값'을 저장

        for (int i = 0; i < stones.length; i++) {
            // 1) 뒤에서부터 현재 값 이하인 인덱스는 제거
            //    -> dq에는 stones[인덱스]가 '내림차순'으로 남음 (앞쪽이 항상 최대)
            while (!dq.isEmpty() && stones[dq.peekLast()] <= stones[i]) {
                dq.pollLast();
            }

            // 2) 현재 인덱스를 뒤에 추가
            dq.offerLast(i);

            // 3) 윈도우 범위를 벗어난 인덱스(가장 앞)가 있으면 제거
            //    현재 i가 윈도우의 끝이라 보면, 유효 범위는 [i - k + 1, i]
            if (dq.peekFirst() <= i - k) {
                dq.pollFirst();
            }

            // 4) i가 k-1 이상일 때부터 윈도우가 완성됨 → 최대값 갱신
            if (i >= k - 1) {
                int windowMax = stones[dq.peekFirst()]; // dq의 맨 앞이 현 윈도우 최대
                answer = Math.min(answer, windowMax);   // 최대들 중 최소를 유지
            }
        }
        return answer;
    }
}


// 문제 구조: 길이 k인 모든 구간의 최댓값을 구하고, 그들 중 최솟값을 반환해야 함.
// 비효율 회피: 매 구간을 정렬/스캔하면 O(n·k) 또는 O(n·k log k)가 되어 시간 초과 위험.
// 모노톤 데크: 데크에 값 내림차순이 되도록 인덱스를 유지하면,
// 맨 앞은 항상 현재 윈도우의 최댓값 인덱스
// 새 값이 들어올 때, 자신보다 작거나 같은 값들의 인덱스는 뒤에서 제거 → 쓸모없음(앞으로 최대가 될 가능성 0)
// 범위 밖 인덱스는 앞에서 제거
// → 각 인덱스는 한 번 들어오고 한 번 나가서 전체 O(n)


// 내 답변 but 효율성은 통과 못함
import java.util.*;
class Solution {
    public int solution(int[] stones, int k) {
        
        int maxSet = Integer.MAX_VALUE;
        
        // for문 3개씩 묶어서 진행
        for(int i = 0 ; i < stones.length - k + 1 ; i++){
            int[] threeSet = new int[k];
            for(int j = 0 ; j < k ; j++){
                threeSet[j] = stones[i+j];
            }
            Arrays.sort(threeSet);
            
            if(maxSet > threeSet[k-1]){
                maxSet = threeSet[k-1];
            }
        
        }
        return maxSet;
    }
}
